'use client';

import { useCallback } from 'react';
import { toPng } from 'html-to-image';
import { usePlanStore } from '@/stores/planStore';
import { useToastStore } from '@/stores/toastStore';
import * as Sentry from '@sentry/nextjs';

interface UsePlannerExportOptions {
  targetRef: React.RefObject<HTMLDivElement | null>;
  filename?: string;
  beforeCapture?: () => void;
  afterCapture?: () => void;
}

interface UsePlannerExportReturn {
  exportAsPng: () => Promise<void>;
  exportAsPdf: () => Promise<void>;
  isExporting: boolean;
}

const formatDate = () => {
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
};

const filterNode = (node: HTMLElement): boolean => {
  if (!node.getAttribute) return true;
  return !node.hasAttribute('data-export-ignore');
};

export function usePlannerExport({
  targetRef,
  filename = '수강계획',
  beforeCapture,
  afterCapture,
}: UsePlannerExportOptions): UsePlannerExportReturn {
  const isExporting = usePlanStore((s) => s.isExporting);

  const executeExport = useCallback(
    async (format: 'png' | 'pdf') => {
      if (!targetRef.current) return;

      try {
        // Step 1: Set isExporting in Zustand
        usePlanStore.getState().setIsExporting(true);

        // Step 2: Call beforeCapture callback
        beforeCapture?.();

        // Step 3: Wait for DOM re-render (double-rAF)
        await new Promise<void>((resolve) => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              resolve();
            });
          });
        });

        // Step 4: Capture
        const dataUrl = await toPng(targetRef.current, {
          backgroundColor: '#ffffff',
          pixelRatio: 2,
          filter: filterNode,
        });

        // Step 5: Download
        if (format === 'png') {
          const link = document.createElement('a');
          link.download = `${filename}_${formatDate()}.png`;
          link.href = dataUrl;
          link.click();
        } else {
          const { jsPDF } = await import('jspdf');

          const img = new Image();
          img.src = dataUrl;
          await new Promise<void>((resolve) => {
            img.onload = () => resolve();
          });

          const imgWidth = img.width;
          const imgHeight = img.height;

          const isLandscape = imgWidth > imgHeight;
          const pdf = new jsPDF({
            orientation: isLandscape ? 'landscape' : 'portrait',
            unit: 'mm',
            format: 'a4',
          });

          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          const margin = 10;
          const usableWidth = pageWidth - margin * 2;
          const usableHeight = pageHeight - margin * 2;

          const scale = usableWidth / imgWidth;
          const scaledHeight = imgHeight * scale;

          if (scaledHeight <= usableHeight) {
            pdf.addImage(dataUrl, 'PNG', margin, margin, usableWidth, scaledHeight);
          } else {
            const fitScale = Math.min(usableWidth / imgWidth, usableHeight / imgHeight);
            const finalWidth = imgWidth * fitScale;
            const finalHeight = imgHeight * fitScale;
            const xOffset = margin + (usableWidth - finalWidth) / 2;
            pdf.addImage(dataUrl, 'PNG', xOffset, margin, finalWidth, finalHeight);
          }

          pdf.setFontSize(8);
          pdf.setTextColor(150);
          pdf.text(
            `Generated by Course Planner · ${formatDate()}`,
            pageWidth / 2,
            pageHeight - 5,
            { align: 'center' }
          );

          pdf.save(`${filename}_${formatDate()}.pdf`);
        }

        useToastStore.getState().addToast({
          message: `${format === 'png' ? 'PNG 이미지' : 'PDF 문서'}로 내보내기 완료`,
          type: 'success',
          duration: 3000,
        });
      } catch (error) {
        Sentry.captureException(error);
        useToastStore.getState().addToast({
          message: '내보내기에 실패했습니다.',
          type: 'warning',
          duration: 3000,
        });
      } finally {
        // Step 6: Restore state
        usePlanStore.getState().setIsExporting(false);
        afterCapture?.();
      }
    },
    [targetRef, filename, beforeCapture, afterCapture]
  );

  const exportAsPng = useCallback(() => executeExport('png'), [executeExport]);
  const exportAsPdf = useCallback(() => executeExport('pdf'), [executeExport]);

  return { exportAsPng, exportAsPdf, isExporting };
}
